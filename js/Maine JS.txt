1.  Number, String и Boolean - функции преобразования величин в соответствующие типы.
	Если задать в Number не число выдаст NaN.

2.  var xxx = prompt("Выбери число ", ""); - диалоговое окно с вопросом, в переменную xxx ляжет выбранное число.

3.  isNaN – функция, которая возвращает true, только если её аргумент – NaN (не число).

4.  counter = counter + 1
    counter += 1
    counter++

5.  var xxx = 0;
    while(xxx <= 10){
        xxx = xxx + 1;
        console.log(xxx); ---> 1,2,3,4,5,6,7,8,9,10,11 (каждый шаг)
    }
    console.log(xxx); ---> 11 (тотал результат)

6.  var xxx = 1;
    for (var counter = 0; counter < 3; counter = counter + 1){
        xxx = xxx * 2;
        console.log(xxx); ---> 2,4,8,16 (каждый шаг)
    }
    console.log(xxx); ---> 16 (тотал результат)

7.  break - прерывание цыкла
    for (var xxx = 1; ; xxx++) {
        if (xxx % 5 == 0){
            console.log(xxx); ---> 5 (нужное число)
            break;
            console.log(xxx); ---> нет вывода
        }
        console.log(xxx); ---> 1,2,3,4 (каждый шаг)
    }
    console.log(xxx); ---> 5 (тотал результат)

8.  continue - переход на следующую итерацию

9.  распространение переменных внутри и все конструкции:
    a)  for (x = 0; x <= 4; x++) {
            var y = '';
            y = y + '#';
            console.log(y); ---> 5(#) (пять ступеней цикла)
        }
        console.log(y); ---> # (полледняя ступень цикла)

    b)  var y = '';
        for (x = 0; x <= 4; x++) {
            y = y + '#';
            console.log(y); ---> #
                                 ##
                                 ###
                                 ####
                                 ##### (пять ступеней цикла)
        }
        console.log(y); ---> ##### (полледняя ступень цикла)

10.  switch (prompt("Как погодка?")) {
      case "дождь":
        console.log("Не забудь зонт.");
        break;
      case "солнечно":
        console.log("Оденься полегче.");
        //пропущен break; цикл не прерван, а значит оба ответы "солнечно" и "облачно" дадут результат "Иди гуляй"//
      case "облачно":
        console.log("Иди гуляй.");
        break;
      default:
        console.log("Непонятная погода!");
        break;
    }

11. length - длина строки
    var xxx = "Shalke-04";
    console.log(xxx.length);
    ---> 9

12. Параметры функции – такие же переменные, но их начальные значения задаются при вызове функции, а не в её коде.
    return - определяет значение, возвращаемое функцией.
    var square = function(x, y, z) {
        var result = (x * y);   ---> 6
        for (var count = 0; count < z; count++){
            result += (x * y);  ---> 6+6 ...
        }
        return result;  ---> 36
    };
    console.log(square(2, 3, 5));   ---> 36

13. Область видимости переменных
    a)  var x = "F0";
        var f1 = function() {
            var x = "F1";   ---> создана локальная переменная внутки функции
            console.log(x); ---> F1
            x = "F2";   ---> перезаписана локальная переменная
            console.log(x); ---> F2
        };
        f1();
        console.log(x); ---> F0

    b)  var x = "F0";
        var f1 = function() {
            x = "F3";   ---> перезаписана глобальная переменная
            console.log(x); ---> F3
        };
        f1();
        console.log(x); ---> F3

14.
    a)  console.log( x ); ---> underfined
        var x = future();
        console.log( x ); ---> Ja Ja Naturlich

        function future() {
            return "Ja Ja Naturlich";
        }

    b)  function chicken() {
            var a = egg(); ---> 1.запуск вложенной функции egg.
            console.log(a); ---> 3.теперь в переменной (12) - результат функции egg.
            var c = 1 + 2 + a;
            return c; ---> 4.возвращает (15) - результат функции chicken.
        }
        function egg() {
            var b = 5+7;
            return b; ---> 2. возвращает данные (12) расчитанные в данной функции egg.
        }
        console.log(chicken()); ---> 15

15. Замыкания - возможность работать со ссылкой на какой-то экземпляр локальной переменной.
    Функция, замыкающая локальные переменные, называется замыкающей.

----------------------------------------------------------------------------------------------

1. СВОЙСТВА МАССИВОВ

    var todoList = [1,2,3,4,5];
    function myFunc(task) {
      todoList.push(task);     ---> [1,2,3,4,5,7]
      todoList.pop();          ---> [1,2,3,4]
      todoList.unshift(task);  ---> [7,1,2,3,4,5]
      todoList.shift();        ---> [2,3,4,5]
    }
    rememberTo(7)
    console.log(todoList);

    push    - добавляет элем в конец массива.
    pop     - удаляет элем с конца массива.
    unshift - добавляет элем в начало массива.
    shift   - удаляет элем с начала массива.

- indexOf     - поиск элем по массиву начиная с начала
    console.log([1, 2, 3, 4, 5, 4, 3, 2, 1].indexOf(3));       ---> 2
- lastIndexOf - поиск элем по массиву начиная с конца
    console.log([1, 2, 3, 4, 5, 4, 3, 2, 1].lastIndexOf(2));   ---> 6
- slice(start, end) - выборка элем массива начиная с и до (до не включено)
    console.log([5, 6, 7, 8, 9].slice(2, 4));   ---> [7, 8]
- slice(start)      - выборка элем массива начиная с и до конца
    console.log([5, 6, 7, 8, 9].slice(2));      ---> [7, 8, 9]
- concat - склеивает масивы по типу + в строках
    function remove(array, index) {
        return array.slice(0, index).concat(array.slice(index + 1));     от 0 до 2 + от 4 до конца
        ---> ["a", "b", "c", "e", "f"]
        return array.slice(1, index).concat(array.slice(index - 1,4));   от 1 до 2 + от 2 до 3
        ---> ["b", "c", "c", "d"]
    }
    console.log(remove(["a", "b", "c", "d", "e", "f"], 3));

2. СВОЙСТВА СТРОК
    console.log("кокосы".slice(3, 6));   ---> осы
    console.log("кокосы".indexOf("с"));  ---> 4
    - trim - удаляет пробелы, табы и прочее, чистит строку с обеих сторон.
    console.log("  ладно  \n ".trim());  ---> ладно
    - length - длина строки
    console.log("abc".length);   ---> 3
    - charAt - доступ к элементу строки
    console.log("abc".charAt(0));   ---> a
    обращение к строке как к массиву через []
    console.log("abc"[1]);   ---> b

3. КОГДА ВЫЗЫВАЕТСЯ ФУНКЦИЯ, к окружению исполняемого тела функции добавляется особая переменная под названием arguments.

    Обьект arguments имеет длину, где указаны все его свойства с именами 0, 1, 2 ... как в массиве.

    function argumentCounter() {
        console.log("Ты дал мне", arguments.length, "аргумента.");
    }
    argumentCounter("Дядя", "Стёпа", "Милиционер", "Вроде");   ---> Ты дал мне 4 аргумента

    Передаем функции addEntry параметры x,y
    Далее используем эти параметры (типа как переменные)в расчетах функции
    И на конец результат z выводим (addEntry как бы принимает значение z)
    function addEntry(x, y) {
        var z = Math.max(x, y);
        return z;
    }
    console.log(addEntry(2,7));

- Math.random - возвращает рандомное число от 0 до 1 включая 0.
console.log(Math.random());   ---> каждый раз новое число
- Math.floor - округляет число до меньшего
console.log(Math.floor(9.6));   ---> 9
- Math.ceil - округляет число до большего
console.log(Math.ceil(9.6));   ---> 10
- Math.round - округляет число до меньшего или большего (универсал)
console.log(Math.round(9.6));

4. ОБЬЕКТ global

    К глобальной области видимости, где живут глобальные переменные, можно также получить доступ как к объекту.
    Каждая глобальная переменная является свойством этого объекта.
    В браузерах глобальная область видимости хранится в переменной window.

    var myVar = 10;
    console.log('myVar' in window);   ---> true   (myVar является глобальной переменной)
    console.log(window.myVar);        ---> 10

- revers - обращает массив наоборот 1,2,3 ---> 3,2,1
    function reverseArray (a){
        var b = a.reverse();
        return b;
    }
    console.log(reverseArray(["A", "B", "C"])); ---> ["C", "B", "A"]

5. АБСТРАКЦИИ - типа оформление отдельного куска кода в отдельную функцию со своим именем.
    var array = [1, 2, 3];
    for (var i = 0; i < array.length; i++) {
      var current = array[i];
      console.log(current);
    }
    или
    function logEach(array) {
        for (var i = 0; i < array.length; i++)
            console.log(array[i]);
    }
    logEach([1,2,3]);

    интересный пример с передачей console.log как второго параметра функ. .
    где action(array[i]); все равно что console.log(array[i]);

    function forEach(array, action) {
        for (var i = 0; i < array.length; i++)
            action(array[i]);
    }
    forEach(["один", "два", "Три"], console.log); ---> один > два > три

6. ФУНКЦИИ ВЫСШЕГО ПОРЯДКА - это Функции, оперирующие другими функциями – либо принимая их в качестве аргументов, либо возвращая их.
   - это всего лишь переменные, ничего особенного. - позволяют нам абстрагировать действия, а не только значения.

   function greaterThan(n) {
     return function(m) {
      return m > n;
    };
   }
   var xxx = greaterThan(10);

   console.log( xxx(11) );   ---> true
   console.log( xxx(9) );    ---> false

   функция greaterThan(10) с переданным ей параметром n = 10 кладется в переменную xxx.
   вызов переменной xxx как функции тоже с параметром а именно 11, и этот параметр идет уже во внутреннюю функ как m = 11.

   или без вложенных функций это выглядит так:

   function greaterThan(n,m) {
       return m > n;
   }
   console.log(greaterThan(10,11));

   apply - метод которому передают массив (или объект в виде массива) из аргументов, а он вызывает функцию с этими аргументами.

   JSON - JavaScript Object Notation
   JavaScript предоставляет функции JSON.stringify и JSON.parse, которые преобразовывают данные из этого формата и в этот формат.

   stringify() - принимает значение и возвращает строчку с JSON.
       var xxx = JSON.stringify({name: "X", born: 1980});
       console.log(xxx);    // → {"name":"X","born":1980}

   parse(xxx) - принимает такую строчку и возвращает значение.
        var value = JSON.parse(xxx).born;
       console.log(value);    // → 1980

   Содержимое JSON файла:
   var TREE_FILE = "[\n  " + [
       '{"name": "X", "born": 1832, "died": 1905, "sex": "m"}',
       '{"name": "Y", "born": 1876, "died": 1956, "sex": "f"}',
       '{"name": "Z", "born": 1683, "died": 1724, "sex": "m"}'
   ].join(",\n  ") + "\n]";

   var parsedFile = JSON.parse(TREE_FILE);   // преобразовуем строку обратно в массив обьектов
          console.log(parsedFile.length);    // --> 3  всего три обьекта с данными

   У массивов есть несколько полезных методов высшего порядка – forEach:
       filter - фильтрация
       map    - преобразование
       reduce - суммирование

   Фильтруем массив:
   ----------------
   filter - перебирает массив с данными переданный ему первым параметром, и те элементы которые подходят по условию
            кладутся в отдельно созданый новый массив.

   var filteredByBorn = parsedFile.filter(function(person) {
       return person.born > 1800 && person.born < 1900;
   })
   console.log(filteredByBorn);    // --> [{ name="X", ...}, { name="Y", ...}]

   Преобразоваем массив:
   --------------------
   map - преобразовывает массив в новый массив
   (в данном примере выводятся те же данные что и в придыдущем но только имена.)

   function map(array, transform) {
       var mapped = [];
       for (var i = 0; i < array.length; i++)
           mapped.push(transform(array[i]));
       return mapped;
   }

   var filteredByName = map(filteredPerson, function(person) {
       return person.name;
   });
   console.log(filteredByName);    // --> ["X", "Y"]

   Суммируем массив:
   ----------------
- concat - соединяет данные между собой внутри массива.

   var array = [[1, 2], [3, 4]];          // --> [1, 2, 3, 4]          - 2 массива в один
   var array = [[1, 2], 'abc', '2', 5];   // --> [1, 2, "abc", "2", 5] - массив и другие типы данных в один массив
   var array = ['a', 'b', 'c', 5];           // --> abc5               - массив в строку

   var concatArrays = array.reduce(function(a, b){
       return a.concat(b);
   });
   console.log( concatArrays );


   reduce - суммирует эллементы внутри массива
            (но в даннои примере мы используем ее чтоб найти min и max значения возраста)

   var findMinBornDate = parsedFile.reduce(function(min, cur) {
       if (cur.born < min.born) return cur;
       else return min;
   })
   var findMaxBornDate = parsedFile.reduce(function(min, cur) {
          if (cur.born > min.born) return cur;
          else return min;
      })
   console.log(findMinBornDate, findMaxBornDate);    // 1683, 1876


   Узнаем средний возраст мужчин, у нас их 2 из 3 в массиве.
   --------------------------------------------------------
   function average(array) {                        // передаем сюда массив 73, 41
       function plus(a, b) { return a + b; }        // сумируем года
	   
       return array.reduce(plus) / array.length;    // делим на количество мужчин
   }
   function male(p) {               // отфильтровуем мужчин от женщин  (2)
       return p.sex == "m";
   }
   function age(p) {                // узнаем возраст мужчин (73, 41)
       return p.died - p.born;
   }
   var overageManAge = average(parsedFile.filter(male).map(age));
   console.log(overageManAge);    // --> 57


7. ТАЙНАЯ ЖИЗНЬ ОБЬЕКТОВ:
-------------------------
   Методы – свойства, содержащие функции.
   Обычно метод должен что-то сделать с объектом, через который он был вызван

- Object.defineProperties - добавляет свойства в объект:

   Object.defineProperties(mikhail, { name:   { value:        'Mikhail'
                                              , writable:     true
                                              , configurable: true
                                              , enumerable:   true }

                                    , age:    { value:        19
                                              , writable:     true
                                              , configurable: true
                                              , enumerable:   true }

                                    , gender: { value:        'Male'
                                              , writable:     true
                                              , configurable: true
                                              , enumerable:   true }
   });

   Рассмотрим некоторые флаги:

   - writable — значение свойства может быть изменено, используется только для дескрипторов данных.
   - configurable — тип свойства может быть изменён или свойство может быть удалено.
   - enumerable — свойство используется в общем перечислении.
       Дескрипторы данных таковы, что определяют конкретное значение, которое соответствует дополнительному value-параметру, описывающему конкретные данные, привязанные к свойству:
   - value — значение свойства

   Дескрипторы доступа определяют доступ к конкретному значению через getter-ы и setter-ы функций.
   Если не установлены, то по умолчанию равны undefined.

   - get() — функция вызывается без аргументов, когда происходит запрос к значению свойства.
   - set(new_value) — функция вызывается с аргументом — новым значением для свойства,
        когда пользователь пытается модифицировать значение свойства.

   // Синтаксис использования метода addListener:
   MYAPP.event.addListener("yourel", "type", callback);


   Прототипы:
   ---------
   В дополнение к набору свойств, почти у всех обьектов также есть прототип.
   Прототип – это ещё один объект, который используется как запасной источник свойств.
   Когда объект получает запрос на свойство, которого у него нет, это свойство ищется у его прототипа, затем у прототипа прототипа, и т. д.
   (Это прототипное наследование от родителя к ребенку)

   Предок всех объектов, Object.prototype.
       функция Object.getPrototypeOf возвращает прототип объекта.

   Можно использовать Object.create для создания объектов с заданным прототипом переданным в качестве аргумента.

   var protoRabbit = {              // проторип protoRabbit с набором свойств (которые будут у всех кроликов)
     speak: function(line) {
       console.log("А " + this.type + " кролик говорит '" +  line + "'");
     }
   };
   var killerRabbit = Object.create(protoRabbit);    // создание обьекта с прототипом protoRabbit

   killerRabbit.type = "убийственный";    // Данный объект-кролик, убийственный, содержит свойства, применимые только к нему - свой тип,  и наследует разделяемые с другими свойства от прототипа.
   killerRabbit.speak("ХРЯЯЯСЬ!");

   // → А убийственный кролик говорит 'ХРЯЯЯСЬ!'

   Объекты без прототипов:
   ----------------------
   var killerRabbit = Object.create(null);    // создание обьекта без прототипов, можна создать передавая ему в качестве аргумента Null


   Конструкторы:
   ------------
   Более удобный способ создания объектов, наследуемых от некоего прототипа – конструктор.
   Вызов функции с ключевым словом new приводит к тому, что функция работает как конструктор.
   Конструктор создает новый объект и возвращает его, данный обьект доступен изнутри конструктора через переменную this.

   function Rabbit(type) {    // конструктор (имена конструкторов принято начинать с заглавной буквы
     this.type = type;
   }

   var killerRabbit = new Rabbit("убийственный");    // создание нового обьекта через конструктор Rabbit
   var blackRabbit = new Rabbit("чёрный");
   console.log(blackRabbit.type);     // → чёрный

   Прототипом конструктора, является – Function.prototype. (поскольку конструкторы – это тоже функции)
       Конструкторы, как и все функции, автоматически получают свойство под именем prototype,
           которое по умолчанию содержит простой пустой объект, происходящий от Object.prototype.
               Свойство конструктора prototype будет прототипом экземпляров, созданных им, но не его прототипом.
   То есть, чтобы добавить кроликам, созданным конструктором Rabbit, метод speak, мы просто можем сделать так:

   Rabbit.prototype.speak = function(line) {    // добавляем метод speak обьекту созданому конструктором Rabbit через свойство prototype
     console.log("А " + this.type + " кролик говорит '" +   line + "'");
   };
   blackRabbit.speak("Всем капец...");
   // → А чёрный кролик говорит 'Всем капец...'


- instanceof - бинарный оператор позволяющий узнать произошёл ли объект от конкретного конструктора.

    function Rabbit(type) {
        this.type = type;
    }
    var blackRabbit = new Rabbit("чёрный");

    console.log(blackRabbit);                      // Rabbit { type="чёрный"}    конструктор со свойствами
    console.log(blackRabbit.type);                 // чёрный                     свойство type
    console.log(blackRabbit instanceof Rabbit);    // true                       blackRabbit действительно образован конструктором Rabbit
    console.log([2] instanceof Array);             // true                       [2] действительно образован конструктором Array и есть массивом


   Перегрузка унаследованных свойств:
   ---------------------------------
   Когда добавляем свойство объекту, оно добавляется непосредственно к самому объекту. Теперь это его свойство.
   Если в прототипе есть одноимённое свойство, оно больше не влияет на объект. При этом сам прототип не меняется.

   Rabbit.prototype.teeth = "мелкие";     // добавляем свойство teeth обьекту созданому конструктором Rabbit через свойство prototype
       console.log(killerRabbit.teeth);   // → мелкие
       console.log(blackRabbit.teeth);    // → мелкие

   killerRabbit.teeth = "длинные, острые и окровавленные";    // перезаписываем обьекту killerRabbit свойство teeth, которое перекроет то же свойстро от прототипа Rabbit
       console.log(killerRabbit.teeth);   // → длинные, острые и окровавленные
       console.log(blackRabbit.teeth);    // → мелкие

   delete Rabbit.prototype.teeth;         // удаление свойства teeth c прототипа Rabbit
       console.log(killerRabbit.teeth);   // → длинные, острые и окровавленные
       console.log(blackRabbit.teeth);    // undefinet, потому что своего собственного свойства teeth НЕТУ, а с прототипа Rabbit его удалили и там теперь тоже НЕТУ.


   Геттеры и Сеттеры:
   -----------------
   В объявлении объекта записи get или set позволяют задать функцию, которая будет вызвана при чтении или записи свойства.

   var pile = {
       elements: ["скорлупа", "кожура", "червяк"],
       get height() {
           return this.elements.length;
       },
       set height(value) {
           console.log(value);
       }
   };
   console.log(pile.height);    // → 3      отражается количество элем взятое в геттере get
   pile.height = 100;           // → 100    отражается число назначенное в сеттере set

   Можно также добавить такое свойство в существующий объект, к примеру, в prototype,
       используя функцию Object.defineProperty (раньше мы её уже использовали, создавая несчётные свойства).

   Так же можно задавать свойство set в объекте, передаваемом в defineProperty, для задания метода-сеттера.
   Когда геттер есть, а сеттера нет, попытка записи в свойство просто игнорируется.

   НАСЛЕДОВАНИЕ:
   ------------
   Возможность создавать обьекты мало отличимые друг от друга малыми силами.
   Обычно новый конструктор вызывает старый (через метод call, чтобы передать ему новый объект и его значение).
   Мы наследуем прототип конструктора от старого так, что экземпляры этого типа будут иметь доступ к свойствам старого прототипа.
   И наконец, мы можем переопределить некоторые свойства, добавляя их к новому прототипу.

   Наследование – основная часть объектно-ориентированной традиции, вместе с инкапсуляцией и полиморфизмом.
   Тогда как инкапсуляция и полиморфизм используются для разделения частей кода и уменьшения связанности программы,
       наследование связывает типы вместе и создаёт большую связанность.

   КЛАССЫ в JS:
   -----------
   В JS классов нет, но их заменяют конструкторы.
   В прототип-ориентированном подходе нет оператора new, а создание новых объектов производится путем клонирования уже существующих.

    daffy и donald используют один общий метод quack(), который предоставляет им прототип duck.

    С прототипной точки зрения donald и daffy являются клонами объекта duck,
       а с класс-ориентированной — “экземплярами класса” duck.

    Немного о новом синтаксисе:

- Класс (ECMA Script 5)                                   - Класс (ECMA Script 6)
-------------------------------------------------------------------------------------------------------------
                                                    --      class Duck{
    var Duck = function(name){                      --        constructor(name="Unnamed"){
        this.name = name||"Unnamed";                --            this.name = name;
        this.firstWords = this.quack();             --            this.firstWords = this.quack();
    };                                              --        },
    Duck.prototype.quack = function(){              --        quack(){
        return this.name + " Duck: Quack-quack!";   --            return this.name + " Duck: Quack-quack!";
    };                                              --        }
                                                    --      }

ООП:
---
    Объектно-ориентированное программирование (ООП) — это парадигма программирования,
    которая использует абстракции, чтобы создавать модели, основанные на объектах реального мира.
    ООП использует несколько техник из ранее признанных парадигм, включая
        модульность, полиморфизм и инкапсуляция.

1. Полиморфизм – расширение принципа наследования реализуемое с помощью оператора prototype.
   – это когда подкласс класса может вызвать ту же самую обобщенную унаследованную функцию в своем собственном контексте.
   Например:

   //Конструктор родительского класса
       function Animal(name) {
           this.name = name;
       }
       Animal.prototype.speak = function() {
           alert(this.name + " says:");
       }
   //Конструктор унаследованного класса "Dog"
       function Dog(name) {
           Animal.call(this, name);
       }
       Dog.prototype.speak = function() {
           Animal.prototype.speak.call(this);
           alert("woof");
       }
   //Конструктор унаследованного класса "Cat"
       function Cat(name) {
           Animal.call(this, name);
       }
       Cat.prototype.speak = function() {
           Animal.prototype.speak.call(this);
           alert("miaow");
       }

   var dog = new Dog("Fido");     //Создает экземпляр Dog
   dog.speak();                   //Вызывает функцию speak() класса Dog

   var cat = new Cat("Lucy");     //Создает экземпляр Cat
   cat.speak();

2. Инкапсуляция является полезной частью объектно-ориентированного программирования,
   изолирующей данные в экземпляре класса от данных в другом экземпляре того же самого класса.
   Вот почему оператор this используется внутри класса для извлечения данных для данной переменной
   внутри данного экземпляра класса.
   Разделяет код на внутренний и внешний интерфейсы:
   - внутренний, или приватный - не доступны для изменений из вне, то что под капотом
   - внешний, или публичный - это например всякого рода настройки, доступные юзеру.

3. Наследование – один из трех важных принципов объектно-ориентированного программирования.
   Он реализуется в JavaScript с помощью prototype и функции call().
   Новый обьект dog имеет свои уникальные свойства, но так же имеет унасленованные от родителя Animal

    - Пространство имён
        Контейнер, который позволяет связать весь функционал под уникальным, специфичным для приложения именем. app - например
    - Класс
        Определяет характеристики объекта. Класс является описанием шаблона свойств и методов объекта.
    - Объект
        Экземпляр класса.
    - Свойство
        Характеристика объекта, например, цвет.
    - Метод
        Возможности объекта, это подпрограммы или функции, связанные с классом.
    - Конструктор
        Метод, вызываемый в момент создания экземпляра объекта. Он, как правило, имеет то же имя, что и класс, содержащий его.
    - Абстракция
        Совокупность комплексных наследований, методов и свойств объекта должны адекватно отражать модель реальности.
    - Наследование
        Класс может наследовать характеристики от другого класса.
    - Инкапсуляция
        Способ комплектации данных и методов, которые используют данные.
    - Полиморфизм
        Различные классы могут объявить один и тот же метод или свойство.


ПОИСК И ОБРАБОТКА ОШИБОК:
------------------------

    var result = prompt("сколько тебе лет", "");    // вызов попапа с вопросом о возрвсте
        if (isNaN(result)){
            alert(null);                            // если ввели не число
        }
        else {
            alert(result);                          // если ввели число
        }
    console.log(result);


ИСКЛЮЧЕНИЯ:
----------
(unwinding the stack) развёртывание стека -  возврат исключения напоминает некий «прокачанный» возврат из функции –
    он выпрыгивает не только из самой функции, но и из всех вызывавших её функций, до того места, с которого началось выполнение.

- (ключевое слово) throw - используется для выбрасывания исключения.
      ловлей занимается кусок кода, обёрнутый в блок - try,
          за которым следует - catch. (try и catch используюстя всегда в паре)
      еще вместо catch или после него может следовать finally - это код который обязательно будет выполнен после блока try

     function promptDirection(question) {
         var result = prompt(question, "");
         if (result.toLowerCase() == "left") return "L";
         if (result.toLowerCase() == "right") return "R";
         throw new Error("Недопустимое направление: " + result);    // trow - выбрасывает исключение, которое создаем с помощью стандартного конструктора
     }                                                                      - new Error, создающего объект со свойством message
     function look() {
         if (promptDirection("Куда?") == "L")
           return "дом";
         else
           return "двух разъярённых медведей";
     }
     try {                                          // когда код в блоке try выкидывает исключение, выполняется блок catch.
         console.log("Вы видите", look());
     }
     catch (error) {                               // после завершения выполнения блока catch (или же если блок try выполняется без проблем),
         console.log("Что-то не так: " + error);            выполнение переходит к коду, лежащему после инструкции try/catch.
     }
     finally{                                      // в данном примере не используется
         ....
     }

     Переменная, указанная в скобках (error, но может быть любое имя), будет привязана к значению исключения (Error, название только это).


РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ:
--------------------
    Регулярка – тип объекта. Её можно создать, вызвав конструктор RegExp, или написав нужный шаблон, окружённый слешами.

    var r1 = new RegExp("abc");
    var r2 = /abc/;

    \ - обратный слеш нужен для того чтобы предварять (типа экранирует) специальные символы.

    var xxx = /eighteen\+/;

- test (метод):
    console.log(/abc/.test("abcd"));    // → true
    console.log(/abc/.test("abxc"));    // → false
    console.log(/abc/.test("xabcy"));   // → true

    У нескольких групп символов есть свои встроенные сокращения:
        \d – любая цифра
        \w – алфавитно-цифровой символ
        \s – пробельный символ (пробел, табуляция, перевод строки, и т.п.)
        \D – не цифра
        \W – не алфавитно-цифровой символ
        \S – не пробельный символ
        . – любой символ, кроме перевода строки

    var dateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/;
        console.log(dateTime.test("30-01-2003 15:20"));    // → true

    Заметьте, что точка внутри квадратных скобок теряет своё особое значение и превращается просто в точку.
    То же касается и других специальных символов, типа +.

    ^  - Cказать, что вам надо найти любой символ, кроме тех, что есть в наборе
             можно, поставив этот знак сразу после открывающей квадратной скобки.

    +  - если поставить плюс после чего-либо в регулярке,
       это будет означать, что этот элемент может быть повторён более одного раза.
          /\d+/ означает одну или несколько цифр.

    ?  - знак вопроса делает часть шаблона необязательной, то есть она может встретиться ноль или один раз.
          /abc?d/  в тесте и abc и abcd дадут true

    {4}   - после элемента означает, что он должен встретиться в строке 4 раза.
    {2,4} - от 2 до 4 раз.
    { ,4} - до 4 раз.

    var dateTime = /\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/;    // запись аналогична той что была выше

    Чтобы использовать операторы * или + на нескольких элементах сразу, можно использовать круглые скобки.
    () - часть регулярки, заключённая в скобки, считается одним элементом с точки зрения операторов.

    var xxx = /boo+(hoo)+/i;    console.log(xxx.test("Boohoooohoohooo"));    // true

    i - в конце выражения делает регулярку нечувствительной к регистру симолов – так, что "B" совпадает с "b"





11. МОДУЛИ:
----------
    Модули позволяют структурировать большие программы, разделяя код по разным файлам и пространствам имён.
    Функции – единственная вещь в JavaScript, создающая новую область видимости.
    Если нам нужно, чтобы у модулей была своя область видимости, придётся основывать их на функциях.
    Это позволит не засирать глобальную область видимости ненужными переменными.

    var month = function() {
         var names = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
         return {
             name: function(number) {
             return names[number];
             },
             number: function(name) {
             return names.indexOf(name);
             }
         };
     }();
     console.log(month.name(2));               // → March
     console.log(month.number("November"));    // → 10// создание и авто вызов безымянной функции

    Функция month – часть интерфейса модуля, а переменная names – нет.

    Если функ безымянная и не в переменной нужно ее заключать в ();
    (function() {
        .....
    })();

    бъекты в качестве интерфейсов:
    -----------------------------
    Удобно объявить объект (обычно называемый exports) и добавлять к нему свойства каждый раз, когда нам надо что-то экспортировать.
    В следующем примере функция модуля принимает объект интерфейса как аргумент, позволяя коду снаружи функции создать его и сохранить в переменной.

    (function(exports) {
      var names = ["Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота", "Воскресенье"];

      exports.name = function(number) {
        return names[number];
      };
      exports.number = function(name) {
        return names.indexOf(name);
      };
    })(this.weekDay = {});

    console.log(weekDay.name(weekDay.number("Четверг")));
    // → Четверг

    Есть два популярных подхода к использованию модулей.
       Один – CommonJS, построенный на функции require, которая вызывает модули по имени и возвращает их интерфейс.
       Другой – AMD, использующий функцию define, принимающую массив имён модулей и, после их загрузки,
       исполняющую функцию, аргументами которой являются их интерфейсы.


DOM:
---
Каждый элемент DOMа это узел, имеющий свойства:
- nodeType -
   У обычных элементов он равен 1, что также определено в виде свойства-константы document.ELEMENT_NODE.
   У текстовых узлов, представляющих отрывки текста, он равен 3 (document.TEXT_NODE).
- childNodes - указывающее на массивоподобный объект, со свойством length, содержащий его дочерние узлы.
   Но это – экземпляр типа NodeList, не настоящий массив, поэтому у него нет методов вроде forEach
- parentNode - указывает на его родительский узел.
- firstChild и lastChild показывают на первый и последний дочерний элементы, или содержат null у тех узлов, у которых нет дочерних.
- previousSibling и nextSibling указывают на соседние узлы.

Поиск элементов:
---------------
- querySelectorAll -
    var bar = document.querySelectorAll(".our-block .lg-33");

- querySelector - тоже что и верху, только вернет ПЕРВЫЙ элем коллекции.

    getElementsByTagName('a') - возвращает массив с эллементами.
    getElementsById('logo') - по Id
    getElementsByClassName('grid space-10') - возвращает массив елем с сочитанием классов

    var link = document.body.getElementsByTagName('a')[3];
    console.log(link);                                        // возвращает четвертый эллем в массиве
    console.log(link.href);                                   // реф выбранного эллем, но если ссылка с href="#", то она игнорится. (выводится href другого елем)

- replaceChild -
    var image = document.getElementsByTagName('img');    // переменная с картинкой
    var text = document.createTextNode(image.alt);       // создается текст взятый с alt картинок
        image.parentNode.replaceChild(text, image);      // замена картинок альтернативным текстом


АНИМАЦИЯ:
--------
    анимация картинки. она движется по элипсу:

    var elem = document.getElementById('xxx');

    var angle = 0, lastTime = null;
    function animate(time) {
        if (lastTime != null){
            angle += (time - lastTime) * 0.001;
        }
        lastTime = time;
        elem.style.top = (Math.sin(angle) * 20) + "px";    // незначилельный ход вверх и вниз (20)
        elem.style.left = (Math.cos(angle) * 200) + "px";  // значительный ход в лево и право (200)

        requestAnimationFrame(animate);    // последующие вызовы (рекурсия)
    }
    requestAnimationFrame(animate);    // вызов функции первый раз

ОБРАБОТЧИКИ СОБЫТИЙ:
-------------------
    Функция addEventListener регистрирует свой второй аргумент как функцию, которая вызывается, когда описанное в первом аргументе событие случается.

    addEventListener("click", function() {
        console.log("Щёлк!");
    });

    Каждый обработчик событий браузера зарегистрирован в контексте.
     Когда вы вызываете addEventListener, вы вызываете её как метод целого окна,
      потому что в браузере глобальная область видимости – это объект window.
       У каждого элемента DOM есть свой метод addEventListener, позволяющий слушать события от этого элемента.

    var button = document.querySelector("button");
    function once() {
        button.removeEventListener("click", once);    // функция once удаляет обработчик
    }
    button.addEventListener("click", once);    // назначаем обработчик клика, по срабатыванию которого запускается функция once. (любое имя)

    То есть после первого клика обработчик будет удален

    След пример имеет проверку which, какая именно кнопка миши нажата:

    button.addEventListener("mousedown", function(event) {
        if (event.which == 1)
          console.log("Левая");
        else if (event.which == 2)
          console.log("Средняя");
        else if (event.which == 3)
          console.log("Правая");
    });

     По действию (клик) детали произошедшего браузер записывает в «объект события», который передаётся первым аргументом в обработчик.

     button.onclick = function(event) {       // event - обьект события
        alert(event.type + " на " + event.currentTarget);
        alert(event.clientX + ":" + event.clientY);
    }

    - event.type
        Тип события, в данном случае click
    - event.currentTarget
        Элемент, на котором сработал обработчик.
    - event.clientX / event.clientY
        Координаты курсора в момент клика (относительно окна)

- stopPropagation метод объекта события, применяется чтобы «высшие» узлы не получили распространения действия.

- target - ссылается на узел, который запустил обработку.
      возможно использовать свойство target, чтобы распространить обработку конкретного типа события.
      (чтоб не навешивать обработку события на каждую кнопку отдельно)

    <button>A</button>  <button>B</button>  <button>C</button>

    document.body.addEventListener("click", function(event) {
        if (event.target.nodeName == "BUTTON"){
            console.log("Clicked", event.target.textContent);    // --> Clicked B (если клик по Б)
        }
    });

- preventDefault - отменяет дефолтное действие элемента. Например submit не отправляет форму


  Cобытия от кнопок клавиатуры:
  ----------------------------
- keydown -
- keyup -
- keypress -

    - charCodeAt - используем чтобы узнать какой клавише какое число соответствект.
        console.log("V".charCodeAt(0));    // 86
        console.log("v".charCodeAt(0));    // 118

    - event.keyCode - как раз таки числовое значение клавиш
    - event.charCode - буквенное значение клавиш

    addEventListener("keypress", function(event) {
        console.log(String.fromCharCode(event.charCode));    // выводит нажатые вами клавишы, например: a w d s
    });

  Кнопки мыши:
  -----------
- mousedown -
- mouseup -
- mousemove -

    События происходят у тех узлов DOM, над которыми находился курсор мыши.

- pageX и pageY - содержат координаты в пикселях относительно верхнего левого угла (всей страницы)
- clientX и clientY - координаты в пикселях относительно видемой части доки (окно), как и в - getBoundingClientRect
- getBoundingClientRect - возвращает обьект с параметрами: ширины, высоты, позиции X и Y ...

Установка таймеров:
------------------
- setTimeout - запускает дейчтвие через время указанное после функ в милисекундах
    - clearTimeout - отменияет запланированную функцию
- setInterval - для установки таймеров, которые будут повторяться каждые X миллисекунд
    - clearInterval - отменияет запланированную функцию











ECMAScript 6 (2015)
----------------------
Переменные:
    let - видна только в области видимости функции, (как локальная var внутри функции)
          переменная let видна только после объявления, в отличии от var которые существуют и до объявления. они равны undefined
    const - переменная константа, нельзя изменить.

Спред оператор:
    ... - разбирает массив на отдельные элементы.
    let names = ["Илья", "Вася", "Петя"];
    console.log(...names) --> Илья Вася Петя

Строки:
    добавлен новый вид кавычек для строк:
    let str = `обратные кавычки`;   ``(Ё)
    они допускают перенос строки и запись в 2 и более рядов.

    Можно вставлять выражения при помощи ${…}
    let a = 1;
    let b = 2;
    let c = `${a} + ${b} будет равно`;
    let d = `примерно ${a + b}`;
    console.log(c,d);   -->   1 + 2 будет равно примерно 3
    Такую вставку называют «интерполяцией».

    добавлены ряд полезных методов общего назначения:
    где str - некая строка, переменная со строкой.
        s   - кусок строки
    str.includes(s) – проверяет, включает ли одна строка в себя другую, возвращает true/false.
    str.endsWith(s) – возвращает true, если строка str заканчивается подстрокой s.
    str.startsWith(s) – возвращает true, если строка str начинается со строки s.
    str.repeat(times) – повторяет строку str times раз.

Деструктуризация

 массива:
    let [a, b] = ["Илья", "Вася", "Петя"];
    alert(a); // Илья
    alert(b);  // Вася
    массив разбит на части, первый параметр ушел в переменную a, второй соответственно в - b, третий просто отброшен.

 обьекта:
    let options = {
        title: "Меню",
        width: 100,
        height: 200
    };

    let {title, width, height} = options;

    alert(title);  // Меню
    alert(width);  // 100
    alert(height); // 200

    Как видно, свойства options.title, options.width и options.height автоматически присвоились соответствующим переменным.
    а для переименовки переменных запишем через двоеточие

    let {width: w, height: h, title} = options;

    alert(title);  // Меню
    alert(w);      // 100
    alert(h);      // 200

ОБЬЕКТЫ и ПРОТОТИПЫ:

Object.assign
    Функция Object.assign получает список объектов и копирует в первый target свойства из остальных.
    Object.assign(target, src1, src2...) - target получит свойства src1, src2

    let user = { name: "Вася", isAdmin: false };
        // clone = пустой объект + все свойства user
    let clone = Object.assign({}, user);
    console.log(clone.name); --> Вася

    function countdownTimer(target, timeLeft, options = {}){
        let defaults = {
            time : 'seconds',
            container : '.container-block'
        }
        let settings = Object.assign( {}, defaults, options);
        if(settings.time !== defaults.time){
            _conversationFunction(timeLeft, setting.time);
        }
    }
    создание 2 типов настроек, дефолных и настраиваемых. Если настраиваемое время (time) не равно дефолтному значению
        то применить его в функции _conversationFunction.

Object.is(val1, val2)

    Новая функция для проверки равенства значений.
    Возвращает true, если значения value1 и value2 равны, иначе false.
    Она похожа на обычное строгое равенство ===, но есть отличия:

    // Сравнение +0 и -0
    alert( Object.is(+0, -0)); // false
    alert( +0 === -0 );        // true
    // Сравнение с NaN
    alert( Object.is(NaN, NaN) ); // true
    alert( NaN === NaN );         // false

    Свойства-функции можно оформить как методы: "prop: function() {}" → "prop() {}

    Object.setPrototypeOf(obj, proto) – метод для установки прототипа.

    obj.__proto__ – ссылка на прототип.

    Вызов super.walk() из метода объекта rabbit обращается к animal.walk():

    let animal = {
      walk() {
        alert("I'm walking");
      }
    };
    let rabbit = {
      __proto__: animal,
      walk() {
        alert(super.walk); // walk() { … }
        super.walk(); // I'm walking
      }
    };
    rabbit.walk();

    (При обращении через super используется [[HomeObject]] текущего метода, и от него берётся __proto__. Поэтому super работает только внутри методов.)

КЛАССЫ:
    Синтаксис для классов выглядит так:

    class Название [extends Родитель]  {
      constructor
      методы
    }

    Функция constructor запускается при создании new User, остальные методы записываются в User.prototype.

    class User {
      constructor(name) {
        this.name = name;
      }
      sayHi() {
        alert(this.name);
      }
    }
    let user = new User("Вася");
    user.sayHi(); // Вася

    Это объявление примерно аналогично такому:

    function User(name) {
      this.name = name;
    }
    User.prototype.sayHi = function() {
      alert(this.name);
    };

Exstends:

    class Animal { }
    class Rabbit extends Animal { }

    alert( Rabbit.prototype.__proto__ == Animal.prototype ); // true

    new Rabbit доступны как свои методы, так и (через super) методы родителя.
        Это потому, что при наследовании через extends формируется стандартная цепочка прототипов:
            методы Rabbit находятся в Rabbit.prototype, методы Animal – в Animal.prototype, и они связаны через __proto__:

=> Стрелочные функции:

    var myFunc = function(x,y){    функция JS5
        return x + y;
    }

    let myFunc = (x,y) => x + y;   Стрелочная ф-ия JS6

    let person = {
        name: 'Nigga',
        greet: function(){
            alert('Yo, ' + this.name);
            console.log(this);
        }
    }
    person.greet();   --->  Алерт (Yo, Nigga);  this - ссылается на данный обьект person  // Object { name: "Nigga", greet: person.greet() }

    let person = {
        name: 'Nigga',
        greet: () => {
            alert('Yo, ' + this.name);
            console.log(this);
        }
    }
    person.greet();  --->  Алерт (Yo, undefined);  this - ссылается на контекст (окружение) и это в данном случае // HTMLDocument → file:///D:/www/MyMagicCom/index.html.

